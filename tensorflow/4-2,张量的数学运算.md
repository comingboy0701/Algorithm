# 4-2,张量的数学运算


张量的操作主要包括张量的结构操作和张量的数学运算。

张量结构操作诸如：张量创建，索引切片，维度变换，合并分割。

张量数学运算主要有：标量运算，向量运算，矩阵运算。另外我们会介绍张量运算的广播机制。

本篇我们介绍张量的数学运算。


### 一，标量运算

张量的数学运算符可以分为标量运算符、向量运算符、以及矩阵运算符。

加减乘除乘方，以及三角函数，指数，对数等常见函数，逻辑比较运算符等都是标量运算符。

标量运算符的特点是对张量实施逐元素运算。

有些标量运算符对常用的数学运算符进行了重载。并且支持类似numpy的广播特性。

许多标量运算符都在 tf.math模块下。


import tensorflow as tf
import numpy as np

a = tf.constant([[1.0,2.0],[3.0,4.0]],dtype=tf.float32)
b = tf.constant([[5.0,6],[7.0,8.0]],dtype=tf.float32)
# + - * / sqrt > < ==
c = a+b 
tf.print(c)
   
c = a-b 
tf.print(c)

c = a*b 
tf.print(c)

c = a/b 
tf.print(c)

c = a**.5 
tf.print(c)

```python
a = tf.constant([1.0,8.0])
b = tf.constant([5.0,6.0])
c = tf.constant([6.0,7.0])
d = tf.add_n([a,b,c])
tf.print(d)
```

```python
d = tf.minimum(a,b)
tf.print(d)
```

```python
d = tf.maximum(a,b)
tf.print(d)
```

### 二，向量运算

向量运算符只在一个特定轴上运算，将一个向量映射到一个标量或者另外一个向量。
许多向量运算符都以reduce开头。

```python
a = tf.range(1,10)
tf.print(tf.reduce_sum(a))
tf.print(tf.reduce_mean(a))
tf.print(tf.reduce_max(a))
tf.print(tf.reduce_min(a))
tf.print(tf.reduce_prod(a))
```

```python
b = tf.reshape(a,[3,3])
tf.print(b)
```

```python
tf.print(tf.reduce_sum(b,axis=0,keepdims=True))
tf.print(tf.reduce_sum(b,axis=1,keepdims=True))
```

```python
#bool类型的reduce
p = tf.constant([True,False,False])
q = tf.constant([False,False,True])
tf.print(tf.reduce_all(p))
tf.print(tf.reduce_any(q))
```

```python
#利用tf.foldr实现tf.reduce_sum
s = tf.foldr(lambda a,b:a+b,tf.range(10))
tf.print(s)
```

```python
#cum扫描累积
a = tf.range(1,10)
tf.print(tf.math.cumsum(a))
tf.print(tf.math.cumprod(a))
```

```python
#arg最大最小值索引
a = tf.range(1,10)
tf.print(tf.argmax(a))
tf.print(tf.argmin(a))
```

```python
#tf.math.top_k可以用于对张量排序
a = tf.constant([1,2,3,7,4,8])
values,indices = tf.math.top_k(a,len(a),sorted=False)
tf.print(values)
tf.print(indices)
tf.print(len(a))
```

### 三，矩阵运算

矩阵必须是二维的。类似tf.constant([1,2,3])这样的不是矩阵。

矩阵运算包括：矩阵乘法，矩阵转置，矩阵逆，矩阵求迹，矩阵范数，矩阵行列式，矩阵求特征值，矩阵分解等运算。

除了一些常用的运算外，大部分和矩阵有关的运算都在tf.linalg子包中。

```python
#矩阵乘法
a = tf.constant([[1,2],[3,4]])
b = tf.constant([[2,0],[0,2]])
tf.print(a)
tf.print(b)
d = a@b  #等价于tf.matmul(a,b)
print(d)
```

```python
#矩阵转置
a = tf.constant([[1.0,2],[3,4]])
d = tf.transpose(a)
tf.print(d)
```

### 四，广播机制


TensorFlow的广播规则和numpy是一样的:

* 1、如果张量的维度不同，将维度较小的张量进行扩展，直到两个张量的维度都一样。
* 2、如果两个张量在某个维度上的长度是相同的，或者其中一个张量在该维度上的长度为1，那么我们就说这两个张量在该维度上是相容的。
* 3、如果两个张量在所有维度上都是相容的，它们就能使用广播。
* 4、广播之后，每个维度的长度将取两个张量在该维度长度的较大值。
* 5、在任何一个维度上，如果一个张量的长度为1，另一个张量长度大于1，那么在该维度上，就好像是对第一个张量进行了复制。

tf.broadcast_to 以显式的方式按照广播机制扩展张量的维度。

```python
a = tf.constant([1,2,3])
b = tf.constant([[0,0,0],[1,1,1],[2,2,2]])
d = b + a  #等价于 b + tf.broadcast_to(a,b.shape)
tf.print(d)
```

```python
tf.broadcast_to(a,b.shape)
```

```python
#计算广播后计算结果的形状，静态形状，TensorShape类型参数
tf.broadcast_static_shape(a.shape,b.shape)
```

```python
#计算广播后计算结果的形状，动态形状，Tensor类型参数
c = tf.constant([1,2,3])
d = tf.constant([[1],[2],[3]])
tf.broadcast_dynamic_shape(tf.shape(c),tf.shape(d))
```

```python
#广播效果
c+d #等价于 tf.broadcast_to(c,[3,3]) + tf.broadcast_to(d,[3,3])
```
